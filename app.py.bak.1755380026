import os, json, sqlite3, time
from slack_sdk.errors import SlackApiError
from datetime import datetime
from typing import Optional
from flask import Flask, request, jsonify, make_response
from slack_sdk import WebClient
from slack_sdk.signature import SignatureVerifier
from dotenv import load_dotenv

load_dotenv()
SLACK_BOT_TOKEN = os.getenv("SLACK_BOT_TOKEN")
SLACK_SIGNING_SECRET = os.getenv("SLACK_SIGNING_SECRET")
PORT = int(os.getenv("PORT", "3000"))
if not SLACK_BOT_TOKEN or not SLACK_SIGNING_SECRET:
    raise RuntimeError("Missing SLACK_BOT_TOKEN or SLACK_SIGNING_SECRET in .env")

app = Flask(__name__)
client = WebClient(token=SLACK_BOT_TOKEN)
verifier = SignatureVerifier(SLACK_SIGNING_SECRET)

DB_PATH = "corpus.db"
def init_db():
    import sqlite3
    with sqlite3.connect(DB_PATH) as conn:
        conn.execute("""CREATE TABLE IF NOT EXISTS corpus (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ts TEXT, user TEXT, channel TEXT,
            kind TEXT, text TEXT, payload_json TEXT, created_at TEXT
        )""")
init_db()

def log_corpus(kind, text="", user="", channel="", payload=None):
    import sqlite3
    try:
        with sqlite3.connect(DB_PATH) as conn:
            conn.execute("INSERT INTO corpus (ts,user,channel,kind,text,payload_json,created_at) VALUES (?,?,?,?,?,?,?)",
                         (str(time.time()), user or "", channel or "", kind, text or "", json.dumps(payload or {}), datetime.utcnow().isoformat()))
    except Exception as e:
        print(f"[corpus] log error: {e}")

def verify_request(req) -> bool:
    try:
        return verifier.is_valid_request(req.get_data(), req.headers)
    except Exception as e:
        print(f"[signing] verification error: {e}")
        return False

@app.get("/healthz")
def healthz():
    return "ok", 200

@app.post("/slack/events")
def slack_events():
    if not verify_request(request): return make_response("invalid signature", 401)
    body = request.get_json(silent=True) or {}
    if body.get("type") == "url_verification":
        return jsonify({"challenge": body.get("challenge")})
    if body.get("type") == "event_callback":
        event = body.get("event", {})
        if event.get("type") == "message" and not event.get("bot_id"):
            log_corpus("event", event.get("text",""), event.get("user",""), event.get("channel",""), event)
        if event.get("type") == "app_mention":
            try:
                client.chat_postMessage(channel=event.get("channel"), thread_ts=event.get("ts"),
                    text="Try `/lens` to pick a review lens, or `/decide <prompt>` for a decision template.")
            except Exception as e:
                print(f"[events] post error: {e}")
    return make_response("", 200)

@app.post("/slack/interactivity")
def interactivity():
    if not verify_request(request):
        return make_response("invalid signature", 401)

    # Parse payload safely
    payload_raw = request.form.get("payload", "{}")
    try:
        payload = json.loads(payload_raw)
    except Exception:
        payload = {}

    user_id = (payload.get("user") or {}).get("id", "")
    channel_id = (
        (payload.get("channel") or {}).get("id")
        or (payload.get("container") or {}).get("channel_id", "")
    )

    # Log every interaction
    log_corpus(
        kind="interaction",
        text=(payload.get("message") or {}).get("text", ""),
        user=user_id,
        channel=channel_id,
        payload=payload,
    )

    # ---------- Block actions (buttons) ----------
    if payload.get("type") == "block_actions":
        action = (payload.get("actions") or [{}])[0]
        aid = action.get("action_id", "")
        selected = action.get("value", "")

        # A) Publish Decision Template from ephemeral to the channel
        if aid == "post_brief":
            try:
                original_blocks = (payload.get("message") or {}).get("blocks", [])
                client.chat_postMessage(channel=channel_id, text="Decision Template", blocks=original_blocks)
                client.chat_postEphemeral(channel=channel_id, user=user_id, text="Posted to channel ✅")
                log_corpus("decision_posted", "decision template posted", user_id, channel_id, payload)
            except Exception as e:
                print("[interactivity/post_brief] error:", repr(e))
            return make_response("", 200)

	# B) Lens buttons → return a useful checklist
	if aid.startswith("lens_") or selected in {"cfo_skeptic","builder_ceo","scaler","challenger","operator"}:
    		responses = {
       			"cfo_skeptic": "CFO Skeptic checklist:\n• Payback < 12 months?\n• Cash vs EBITDA?\n• Sensitivity to accuracy deltas?\n• Hidden costs (services/data/change mgmt)?",
       			"builder_ceo": "Builder CEO lens:\n• Ship a thin slice this week.\n• What becomes faster?\n• Delete work, don’t add it.\n• 90-day compounding?",
       			"scaler":      "Scaler lens:\n• Repeatable playbook?\n• Unit econ at 10× volume?\n• Runbooks + guardrails?",
       			"challenger":  "Challenger lens:\n• Which sacred cow to challenge?\n• If starting fresh, is this the path?",
   			"operator":    "Operator lens:\n• Who owns the KPI?\n• SOP + SLA?\n• Rollback plan if metrics slip?"
    		}
    			client.chat_postEphemeral(
        		channel=channel_id,
        		user=user_id,
        		text=responses.get(selected, f"Lens applied: {selected}")
    		)
    		return make_response("", 200)


    # ---------- Modal submissions (if you add the /decide modal) ----------
    if payload.get("type") == "view_submission" and (payload.get("view") or {}).get("callback_id") == "decide_modal":
        try:
            view = payload.get("view", {})
            state = (view.get("state") or {}).get("values", {})
            get = lambda bid: ((state.get(bid, {}) or {}).get("v", {}) or {}).get("value", "")

            title = (get("title") or "Decision").strip()
            context = (get("context") or "").strip()
            options_text = (get("options") or "").strip()
            recommendation = (get("recommendation") or "").strip()
            risks = (get("risks") or "").strip()

            pm = json.loads(view.get("private_metadata") or "{}")
            chan = pm.get("channel_id") or channel_id
            usr = pm.get("user_id") or user_id

            blocks = [
                {"type":"header","text":{"type":"plain_text","text": title[:150]}},
                {"type":"section","text":{"type":"mrkdwn","text": f"*Context*\n{context or '—'}"}},
                {"type":"section","text":{"type":"mrkdwn","text": f"*Options*\n{options_text or '—'}"}},
                {"type":"section","text":{"type":"mrkdwn","text": f"*Recommendation*\n{recommendation or '—'}"}}
            ]
            if risks:
                blocks.append({"type":"section","text":{"type":"mrkdwn","text": f"*Risks & Mitigations*\n{risks}"}})

            client.chat_postEphemeral(channel=chan, user=usr, text="Decision Brief", blocks=blocks)
            log_corpus("decision", f"{title} | {recommendation}", usr, chan, payload)
        except Exception as e:
            print("[interactivity/decide_modal] error:", repr(e))
        return jsonify({"response_action": "clear"})

    # Default ack
    return make_response("", 200)

def commands():
    if not verify_request(request):
        return make_response("invalid signature", 401)

    form = request.form
    cmd = form.get("command")
    user_id = form.get("user_id")
    channel_id = form.get("channel_id")
    text = form.get("text", "")

    # Log the raw form payload
    log_corpus("command", text, user_id, channel_id, dict(form))

    if cmd == "/lens":
        # 1) Minimal ack so Slack accepts the command
        ack = jsonify({"response_type": "ephemeral", "text": "Pick a lens below ⬇️"})

        # 2) Try to send the interactive card via Web API
        try:
            resp =print("[/lens] blocks json:", json.dumps(lens_picker_blocks()))
            client.chat_postEphemeral(
                channel=channel_id,
                user=user_id,
                text="Which lens do you want to apply?",
                blocks=lens_picker_blocks(),
            )
            print("[/lens] chat_postEphemeral ok:", resp.data if hasattr(resp, "data") else resp)
        except SlackApiError as e:
            print("[/lens] Slack error:", e.response.get("error"))
            print("[/lens] Needed scopes? chat:write. Channel:", channel_id, "User:", user_id)
        except Exception as e:
            print("[/lens] Other error:", repr(e))

        return ack

    if cmd == "/decide":
        prompt = text.strip() or "No prompt provided."
        return jsonify({
            "response_type": "ephemeral",
            "blocks": decision_template_blocks(prompt)
        })

    return jsonify({
        "response_type": "ephemeral",
        "text": f"Unsupported command `{cmd}`. Try `/lens` or `/decide`."
    })
@app.post("/slack/commands")
def commands():
    if not verify_request(request):
        return make_response("invalid signature", 401)

    form = request.form
    cmd = form.get("command")
    user_id = form.get("user_id")
    channel_id = form.get("channel_id")
    text = form.get("text", "")

    # Log the raw form payload
    log_corpus("command", text, user_id, channel_id, dict(form))

    if cmd == "/lens":
        # Minimal ack so Slack is happy
        ack = jsonify({"response_type": "ephemeral", "text": "Pick a lens below ⬇️"})

        # Send the interactive card via Web API (buttons)
        try:
            print("[/lens] blocks json:", json.dumps(lens_picker_blocks()))
            client.chat_postEphemeral(
                channel=channel_id,
                user=user_id,
                text="Which lens do you want to apply?",
                blocks=lens_picker_blocks(),
            )
        except Exception as e:
            print("[/lens] post error:", repr(e))

        return ack

    if cmd == "/decide":
        prompt = text.strip() or "No prompt provided."
        return jsonify({
            "response_type": "ephemeral",
            "blocks": decision_template_blocks(prompt)
        })

    return jsonify({
        "response_type": "ephemeral",
        "text": f"Unsupported command `{cmd}`. Try `/lens` or `/decide`."
    })

def lens_picker_blocks():
    return [
        {
            "type": "section",
            "text": {"type": "mrkdwn", "text": "*Which lens do you want to apply?*"}
        },
        {
            "type": "actions",
            "block_id": "lens_actions",
            "elements": [
                {"type": "button", "text": {"type": "plain_text", "text": "CFO Skeptic"},   "action_id": "lens_cfo",       "value": "cfo_skeptic"},
                {"type": "button", "text": {"type": "plain_text", "text": "Builder CEO"},   "action_id": "lens_builder",   "value": "builder_ceo"},
                {"type": "button", "text": {"type": "plain_text", "text": "Scaler"},        "action_id": "lens_scaler",    "value": "scaler"},
                {"type": "button", "text": {"type": "plain_text", "text": "Challenger"},    "action_id": "lens_challenger","value": "challenger"},
                {"type": "button", "text": {"type": "plain_text", "text": "Operator"},      "action_id": "lens_operator",  "value": "operator"}
            ]
        }
    ]

def decision_template_blocks(prompt: str):
    blocks = [
        {"type": "header", "text": {"type": "plain_text", "text": "Decision Template"}},
        {"type": "section", "text": {"type": "mrkdwn", "text": f"*Prompt:* {prompt or 'No prompt provided.'}"}},
        {"type": "section", "text": {"type": "mrkdwn", "text": "*Options*\n1) Option A\n2) Option B\n3) Option C"}},
        {"type": "section", "text": {"type": "mrkdwn", "text": "*Recommendation*\n<fill in>"}},
        {"type": "section", "text": {"type": "mrkdwn", "text": "*Risks & Mitigations*\n- Risk 1 → Mitigation\n- Risk 2 → Mitigation"}},
        {"type": "context", "elements": [{"type": "mrkdwn", "text": "Use `/decide {prompt}` to regenerate."}]},
        {
            "type": "actions",
            "block_id": "brief_actions",
            "elements": [
                {"type": "button", "text": {"type": "plain_text", "text": "Post to channel"}, "action_id": "post_brief", "value": "post"}
            ]
        }
    ]
    return blocks


# (optional) quick routes introspection for debugging
@app.get("/routes")
def routes():
    return {"routes": sorted(r.rule for r in app.url_map.iter_rules())}

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=PORT, debug=True)
